//
//  AlignmentRules.swift
//  AppleDarthVader
//
//  Created by 杨俊艺 on 2025/11/21.
//

import SwiftUI

#Preview {
	Text("Hello")
		.frame(width: 100, height: 100)
}

// 我们在前⾯的部分讨论过固定的 frame 总会使⽤我们所指定的尺⼨,在本例中是 100⨉100
// frame 修饰器拥有⼀个默认值为 .center 的 alignment 参数
// 为了简单起⻅我们假设 Text 报告的尺⼨是 50⨉20, 当放置这个⼦视图时 frame 修饰器将执⾏以下步骤
// 1. 它向⼦视图询问⽔平中⼼,由于⼦视图的宽度是 50 所以它将⾃⼰的⽔平中⼼报告为 25 (在⼦视图的本地视图坐标系中) 这个值被叫做⼦视图的⽔平中⼼对⻬参考线
// 2. 它向⼦视图询问垂直中⼼,这个⼦视图的⾼度为 20 所以它将⾃⼰的垂直中⼼报告为 10,这是⼦视图的垂直中⼼对⻬参考线
// 3. .frame 计算⾃⼰的⽔平和垂直中⼼,结果为 (50, 50)
// 4. 现在 frame 可以将⼦视图中⼼对⻬了,通过计算两个中⼼点的差值 (50-25，50-10) 并将⼦视图的原点放在 frame 坐标空间的 (25, 40) 就可以
// 想要理解 SwiftUI 的对⻬系统最重要的⼀点是理解对⻬总是⽗视图和⼦视图之间“协商”决定的结果
// ⽗视图不会独⾃觉决定⼦视图的放置位置⽽是会向⼦视图协商相关的对⻬参考线然后根据⼦视图⾃⼰的⼤⼩或者其他⼦视图来决定它的位置
// 下⾯是同样的例⼦只不过采⽤了 .bottomTrailing 对⻬
#Preview {
	Text("Hello")
		.frame(width: 100, height: 100, alignment: .bottomTrailing)
}

// 算法和上⾯的 center 对⻬完全相同
// 1. 它向⼦视图询问⼦视图的尾端对⻬参考线。⼦视图回应 50，这个数值是⼦视图在⾃⼰的视图坐标系中的尾边的位置
// 2. 它向⼦视图询问其底部的对⻬参考线。⼦视图回应20
// 3. frame 计算得到它⾃⼰的尾边 (100) 和底边 (100) 的对⻬参考线
// 4. frame 将⼦视图的原点放置在(50, 80) 同样地这也是通过求解 (100-50，100-20) 的差所得到的
// 对于像 frame 这样的视图修饰器对⻬可以在两个⽅向上⽣效
// frame 的对⻬参数类型是 Alignment，它是⼀个组合了 HorizontalAlignment (⽔平对⻬) 和 VerticalAlignment (垂直对⻬) 的组合结构体
// 其他能够在两个⽅向上进⾏对⻬的类型包括 .overlay，.background 和 ZStack
// 相⽐之下 VStack 只拥有⽔平对⻬⽽ HStack 只拥有垂直对⻬
// 注意 Alignment 类型并不是对⻬参考线它只是决定了在执⾏对⻬时要使⽤哪⼀个对⻬参考线
// HorizontalAlignment 和 VerticalAlignment 结构体内包含了内置的对⻬参考线的静态常量,它们分别是
// 1.⽔平⽅向的 .leading，.center 和 .trailing
// 2.垂直⽅向的 .top，.center，.bottom，.firstTextBaseline 和 .lastTextBaseline
// 组合结构体 Alignment 将这些常量组合起来形成诸如 .topLeading 或 .bottomTrailing 这样的常量
// HorizontalAlignment 和 VerticalAlignment 类型都有⼀个⽅法来计算在给定视图⽅向上的默认值,因此每个视图都⾃动定义了所有的内置对⻬参考线

#Preview { 
	ZStack {
		Rectangle()
			.fill(.teal)
			.frame(width: 50, height: 50)
		Text("Hello, World!")
	}
}

// 因为 ZStack ⾥对⻬的默认值是 .center 所以它将两个⼦视图按照以下步骤进⾏中⼼对⻬
// 1. 确定 ZStack ⾃⼰的尺⼨：
//		1. 向第⼀个⼦视图 (带有蓝⾊矩形的 frame 视图) 询问它的尺⼨和中⼼对⻬参考线。它回应尺⼨为 50⨉50，对⻬点为 (25, 25)
//		2. 向第⼆个⼦视图 (Text，我们假设它的尺⼨是 100⨉20) 询问尺⼨和中⼼对⻬参考线。它回应尺⼨为 100⨉20，对⻬点为 (50, 10)
//		3. 计算 Text 相对于矩形的原点位置，通过将两个对⻬点相减，可以得到结果：(25, 25) - (50, 10) = (-25, 15)
//		4. 确定每个⼦视图的框架：框架指的是⼦视图的原点和尺⼨的组合
//		5. 计算两个⼦视图框架的并集，这个并集的原点为 (-25, 0)，尺⼨为100x50。该尺⼨将被作为 ZStack ⾃⼰的尺⼨
// 2. 放置 ZStack 的⼦视图：
//		1. 基于步骤 1 中计算出的尺⼨，ZStack 算出⾃⼰的中⼼为 (50, 25)
//		2. 计算矩形⼦视图的原点，⽤ ZStack 的中⼼点减去矩形的对⻬点：(50, 25) - (25, 25) = (25, 0)
//		3. 计算 Text 的原点，⽤ ZStack 的中⼼点减去⽂本的对⻬点：(50, 25) - (50, 10) = (0, 15)
//更通⽤地描述每个容器视图在对⻬它的⼦视图时采⽤如下⽅式：
// 1. 确定⾃身尺⼨：
//		1. 确定它的⼦视图的尺⼨。这具体取决于特定视图的类型，我们在本章的第⼀部分已经讨论过这个问题了
//		2. 基于容器的对⻬⽅式，向⼦视图们询问它们的对⻬参考线
//		3. 使⽤任意⼀个特定的⼦视图作为参考计算所有⼦视图的框架
//		4. 计算这些⼦视图框架的并集将所得到的结果尺⼨作为容器的尺⼨
// 2. 放置⼦视图：
//		1. 依据容器视图⾃⼰的尺⼨计算出它⾃⼰的对⻬参考线
//		2. 通过从容器视图的对⻬参考线中减去⼦视图的对⻬参考线计算出每个⼦视图的原点
// 依据我们要处理的容器视图的不同第⼀个步骤可能会被部分或者完全省略
// ⽐如说这个容器被包裹在同时给定了宽和⾼的固定 frame 中这时它的尺⼨就已知了或者容器位于 overlay 中
// 它的尺⼨永远基于主要⼦视图所以这时对⻬就不再决定 overlay 的尺⼨了
